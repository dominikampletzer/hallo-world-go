= Compare Functional Programming in Go with Lua

- What is Lua?
- Comparison Go vs Lua - Structure and Features
- Functional Programming in Lua
- Differences by Examples

erstmal rausfinden wie es in Go geht :)


= What is Lua?

Lua is a Programming Language which was released, designed, implemented and maintained 1993 by PUC-Rio,
the Pontifical Catholic University of Rio de Janeiro in Brazil. Till Version 4 it was under the
BSD-Licence since Version 5 its under MIT-Licence.

Lua creators call it a powerful, efficient, lightweight, embeddable scripting language.
It supports procedural programming, object-oriented programming, functional programming,
data-driven programming, and data description.

This sounds nice, but for which use cases are Lua made, or why choose Lua?

Lua is very small and embeddable. It has a small footprint and can embed easily into every platform
with a standard C compiler. It is currently the leading scripting language in video games. (for Example:
World of Warcraft or Angry birds)

First Lua is implemented as a library

Designed for embedding and extending

== Goals of Lua

- Portability: Runs on most platforms we ever heard of, Runs inside OS kernels, Written in ANSI C
- Simplicity: Well documented C Api and free Manual 100 pages (proxy for complexity)
- Small size
- Scripting: dynamic Language - scripting emphasizes inter-language communication;
Program written in two languages; System Language implements the hard parts of the application - scripting glues
together the hard parts

= Comparison Go vs Lua - Structure and Features

|===
|Feature |Go |Lua

|Multiple Projects
|Yes
|Yes

|Target audience
|Cloud computing, Web Development, App developer, Distributed Systems, Embedded system, Systems Programming
|Embedded system, Game developer industry

|Release Date
|2009
|1993

|Typing
|Static
|Dynamic

|Programming paradigm
|Concurrency Oriented, Object-oriented, Imperative programming, reflective
|Imperative programming, Object-oriented, Functional, Metaprogramming

|Supported VCS
|Any
|Git

|Embeddable
|Yes
|Yes

|Asynchronously
|Go-Routines, Channels + Locks
|Coroutines

|Exception Handling
|panic/recover
|Yes, Lua ends the current chunk and returns to the application pcall (like try/catch)

|Public/Private
|Implicit by default by Spelling/Writing
|Privacy by Local Variables or keep Objects/Tables in Closure

|Objects
|By Embedding and throu interfaces
|Tables

|Interfaces
|Yes
|No

|Compiled
|Yes
|Yes

|Inheritance
|Multiple by Interfaces
|Multiple Prototyping

|===

= Scope / Values References / Functions

go auf lexical scoping überprüfen

== Function Nested
    function foo(x)
        function p(y)
            print(y)
        end
        p(2*x)
    end

== anonymous Functions
    add = (function (x,y) return x+y end)

Functions are First-Class Values
Functions can be stored in variables and data structures
Can be passed as arguments to and returned by other functions (higher-order functions)
They can called anywhere in a program

== Lexical Scoping

Unlike global variables, local variables have their scope limited to the block where they are
declared. A block is the body of a control structure, the body of a function, or a chunk
(the file or string with the code where the variable is declared).

That is the same as for functions, so we could create typical closures like

 function sequence ()
      local i = 0
      return function ()
               i ++
               return i
             end
 end

= importing of Modules
lua

    local m = require "math"
    print(m.sqrt(10))

maybe to dynamic you cant check if there really math. there could be every expression

go

    import "fmt"

== eval

lua doesnt have eval function like js it has a load function (historical reason)
load separated compilation from execution
load is a pure function
any code always runs inside some function

- we can declare local variables which naturally work like static variables for the functions inside the chunk
- chunks can return values

    function eval (code)
        -- compiles source 'code' and executes the result
        return load(code)()
    end

= Closures
 function sequence ()
      local i = 0
      return function ()
               i ++
               return i
             end
    end


= generic for
 for k, v in pairs(t) do
    print(k, v)
 end

 for <var-list> in <exp-list> do
      <body>
  end

https://www.lua.org/pil/7.1.html

= Interfaces?? / Objects

The table type implements associative arrays. An associative array is an array that can be indexed not only with numbers,
 but also with strings or any other value of the language, except nil. Moreover, tables have no fixed size; you can add
 as many elements as you want to a table dynamically. Tables are the main (in fact, the only) data structuring mechanism
  in Lua, and a powerful one. We use tables to represent ordinary arrays, symbol tables, sets, records, queues, and
  other data structures, in a simple, uniform, and efficient way. Lua uses tables to represent packages as well. When we
   write io.read, we mean "the read entry from the io package". For Lua, that means "index the table io using the string
    "read" as the key".

Tables in Lua are neither values nor variables; they are objects. If you are familiar with arrays in Java or Scheme,
then you have a fair idea of what we mean. However, if your idea of an array comes from C or Pascal, you have to open
your mind a bit. You may think of a table as a dynamically allocated object; your program only manipulates references
(or pointers) to them. There are no hidden copies or creation of new tables behind the scenes. Moreover, you do not have
 to declare a table in Lua; in fact, there is no way to declare one. You create tables by means of a constructor
  expression, which in its simplest form is written as {}:

first-class functions + tables ~ objects
syntactical sugar for methods - handles self

a:foo(x) => a.foo(a,x)

    function a:foo(x)
        ...
    end

=>

    a.foo = function(self,x)
        ...
    end

Lua doesn´t need Interfaces in the usual meaning. An interface says that an Object which includes an Interface has specific
functions, methods or properties. But in Lua there are no Objects like in Java. But OO Programming way is possible if
functions and tables are seen as an Object

= Asynchrounes /Synchrones Routinen vs Coroutines
A coroutine is similar to a thread (in the sense of multithreading): a line of execution, with its own stack, its own
local variables, and its own instruction pointer; but sharing global variables and mostly anything else with other
 coroutines. The main difference between threads and coroutines is that, conceptually (or literally, in a multiprocessor
  machine), a program with threads runs several threads concurrently. Coroutines, on the other hand, are collaborative:
   A program with coroutines is, at any given time, running only one of its coroutines and this running coroutine only
    suspends its execution when it explicitly requests to be suspended.

Coroutine is a powerful concept. As such, several of its main uses are complex. Do not worry if you do not understand
some of the examples in this chapter on your first reading. You can read the rest of the book and come back here later.
 But please come back. It will be time well spent.
(zusammenstampfen. alles geklaut)

coroutine has 3 states: suspended, running, dead
it can stores in a variable and like:

    co = coroutine.create(function ()
           for i=1,10 do
             print("co", i)
             coroutine.yield()
           end
         end)

Now, when we resume this coroutine, it starts its execution and runs until the first yield:

    coroutine.resume(co)    --> co   1

If we check its status, we can see that the coroutine is suspended and therefore can be resumed again:

    print(coroutine.status(co))   --> suspended

This can be done till the for-loop is ending. than the state of the coroutine is dead. and it could not longer be called
without an exception.

coroutines are a kind of collaborative multithreading. there a not constructed as real multithreading like go-routines.
While a coroutine is running, it cannot be stopped from the outside
However, with non-preemptive multithreading, whenever any thread calls a blocking operation, the whole program blocks
until the operation completes.

for exsacmple downloading different files trou http. it could be downloaded in sequence (tooks a long time)
or is there currently no data available the coroutines could yield and another coroutine could run and so own.

 function download (host, file)
      local c = assert(socket.connect(host, 80))
      local count = 0    -- counts number of bytes read
      c:send("GET " .. file .. " HTTP/1.0\r\n\r\n")
      while true do
        local s, status = receive(c)
        count = count + string.len(s)
        if status == "closed" then break end
      end
      c:close()
      print(file, count)
    end

    function receive (connection)
      connection:timeout(0)   -- do not block
      local s, status = connection:receive(2^10)
      if status == "timeout" then
        coroutine.yield(connection)
      end
      return s, status
    end

The next function ensures that each download runs in an individual thread:

    threads = {}    -- list of all live threads
    function get (host, file)
      -- create coroutine
      local co = coroutine.create(function ()
        download(host, file)
      end)
      -- insert it in the list
      table.insert(threads, co)
    end


= Pointers?
Lua doesn´t offer Pointers (of course internal it uses references to memory) depending on the data-type there were
reference or values copied. Lua handles allocation and deallocation of strungs and other objects

 Or as some people like to put it; all types are passed by value, but function, table, userdata and thread are reference types.

string is also a kind of reference type, but is immutable, interned and copy-on-write - it behaves like a value type,
but with better performance.

Go does offer Pointer to give the developer full control

= Map/Reducer sample

The "canonical" example of a function that takes another function as a parameter is map. Unfortunately map does not come with Lua, so we'll have to code it ourselves.

function map(func, array)
  local new_array = {}
  for i,v in ipairs(array) do
    new_array[i] = func(v)
  end
  return new_array
end

This is a simple map implementation that only works with one array. But it works well:

> return table.concat(map(double, {1,2,3}),",")
2,4,6

A more complex map implementation that works with more than one array is possible:

function mapn(func, ...)
  local new_array = {}
  local i=1
  local arg_length = table.getn(arg)
  while true do
    local arg_list = map(function(arr) return arr[i] end, arg)
    if table.getn(arg_list) < arg_length then return new_array end
    new_array[i] = func(unpack(arg_list))
    i = i+1
  end
end


REDUCER
function foldr(func, val, tbl)
     for i,v in pairs(tbl) do
         val = func(val, v)
     end
     return val
 end

 -- reduce(function, table)
 -- e.g: reduce(operator.add, {1,2,3,4}) -> 10
 function reduce(func, tbl)
     return foldr(func, head(tbl), tail(tbl))
 end

 The pairs function, which iterates over all elements in a table, is similar, except that the iterator function is the next function, which is a primitive function in Lua:

     function pairs (t)
       return next, t, nil
     end



= Exception handling
*lua*
anonymous functison wiht lexical scoping again error handling could use variables form current function usw.
simple semantic you need only 2 functions - there you could see how functional programming is a major part of lua.
simple to interface with other languages

bad
verbose
body cannot return/break
try is not cost-free (but not very expencive)


    local ok, err = pcall(function() <block/error> end) -- protacted Call

    if not ok then
        <exception code>
    end

*Go*

Go includes 2 Error Strategies

the first one is for functions which could return an error which a programmer can´t handle/controle
like http reject

    ok, err = http.Get(url)
    if err != nil {
        return nil, err // error handling
    }

this example shows a common case in which the program should not crash. we only need to handle the
error, maybe throu calling the Get again or what ever.

the second handling is the panic-Function which is reserved for states, behaviour of the program
which absolutly unnormal and need the handled explicitly or will crash it.

    func NewRational(numerator int, denominator int) Rational {
	    if denominator == 0 {
	    	panic("division by zero")
	    }
	    ...
	}
	a := NewRational(1,0)

    func Parde(input string) (s *Syntax, err error){
        defer func() {
            if p:= recover(); p != nil {
                err = fmt.Errorf("internal error: %v", p)
            }
        }()
        // .. parser ..
    }

here you could the that a rational would created which has 0 as a denominator which is absolutely
nonsense and the system could not handle this. -> panic will called and the caller has to handle that
or the program will break


go includes by design the pcall from lua. The aprouch that if the expected behavior of a function
could be a failure that function has an additional result. This saves performance by calling wrapping
the function in a pcall.
The Panic mechanism allows depending of the programmers intention to recover the Program. But sometimes
it is the right response to panic an maybe break the program. These second Strategy is if you want to
write the exaption in a logfile or cleanup after the panic or what ever.

= Dynamic vs Static Typing

One of the Biggest differences are the typing between Lua and Go.
Lua is dynamic typed and Go static typed.
Dynamic vs Static Typing fills a lot of blogs and posts in web also in papers and so on...
Both have its pro´s and con´s so we wont discuss theme here only take a look at them and show the consequences of these
in exsamples

== Assignment

Lua as Go allows multiple assingment like:

    a,b = 1,2

these allows to swap without a swap function

    a,b = b,a

with this aprouch you resive multiple return values

    a,b = f()

a will get the first result b the second one

with dynamic typing you could but different values into one variable (of course not in the same time)

    a = 1
    a = "eins"
    a = f()
    ...

by static typing in go this is not possible

    a,b = 1,2  -- will work. go "knows" that a and b are integers
    a = "eins" -- will throw an exception. TypeError

casts must done explicitly like

    arr_1 := []any{2, 3, 4}
    a = 1
    a = a + arr_1[0].(int)
    or
    arr_2:= []int{1, 2, 3}
    b = 2 + arr_2[0]

should variables be declared before use they must also declared with typing

    b int
    c string
    a = 1 -- works fine
    b = 2 -- will also work
    c = 3 -- will occure an error

This will also effect Function declarations

*Go*

    func foo (a string, b int) string{
        return "Some Value"
    }

    type Any interface{}
    func foo_2(a Any, b Any) Any{
        x string
        b int
        x = a.(string)
        y = b.(int)
        return "Some Value"
    }
    result string
    result = foo_2("Some", 2).(string)


these example shows that the function params could only be string for a and an integer for b. Foo
must return a string. In the second example you have to cast the params and return value to fit
the correct type.
Main benefit is that you use always the correct type and at last during compiling errors will occured
and during runtime. This prevents for deploy errors in code. And it helps a lot for readability and
reuse functions. All the time you now what you need to call functions and which return you will get
after calling.

Lets have a look on Lua

    function foo (n)
        n = n or 1
        n + 1
        return n
    end

In this example you could not answer the questions:
- Which type has the parameter?
- Will you return something? And which type will it have?
- Must the parameter be set?

That's not really objective. There still exist documentation and the function it self shows what it needs.
But you don´t have compiler or Ide support for these kind of functions. Should foo be called like
foo("abc") it will occurs an invalid-type-exception during runtime and in worst case the programme will
break.
One of the main benefits of dynamic typing is it is much easier to write you dont care about expilict
typing. Code is much smaller and the most time the developer know which types he uses or maybe he doenst
care. take a look at anonymos functions you call theme in a defined enviroment were you know the types.
So why should the types explicit (again!) defined if it trivial?


== CHEAT Sheet

https://powerman.name/doc/asciidoc

== Talk about LUA Functions
https://www.youtube.com/watch?v=wdRGOE1N-FA
https://pragprog.com/magazines/2013-05/a-functional-introduction-to-lua
https://www.lua.org/pil/6.html

Quellen
https://www.lua.org
https://www.youtube.com/watch?v=wdRGOE1N-FA (Talk von LUA in Moskau by Roberto Ierusalimschy)
http://vschart.com/compare/lua/vs/go-language
Programming in Lua by Roberto Ierusalimschy, Lua.org, December 2003
The Go Programming Language Donovan, Kernighan