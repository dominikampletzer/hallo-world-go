= Compare Functional Programming in Go with Lua

== Introduction

This article compares two programming languages *Lua* and  *Go(lang)*. This will not include all concepts of these
languages because we have to less time :) and the object orientated aspects will handled in another package.
There is some to say about all the explicit concepts and still problems to compare totally different concepts. Here
it is more done like *Lua* make it this way and *Go* that way.

Ok. That`s enough blabla. Start with Facts :)

== What is Lua?

Lua is a Programming Language which was released, designed, implemented and maintained 1993 by PUC-Rio,
the Pontifical Catholic University of Rio de Janeiro in Brazil. Till Version 4 it was under the
BSD-Licence since Version 5 its under MIT-Licence.

In the first Version Lua was created as an library. Forther it grows to a one language.

Lua creators goal is to create a powerful, efficient, lightweight and embeddable scripting language. It based of
concepts of procedural, object-oriented , functional and data-driven programming, also on data description.

Lua is a very small and embeddable language which is focused on portability, size, scripting and simplicity (nobody
say they create a complicate programming language ...). Because of this it has a small footprint, is easy to embed in
platforms which support a standard C compiler and it is a scripting language it is dynamically typed.

It´s easy to create Program written in two languages with Lua. The comparison, that Lua is the glue which holds the
hard parts of the Program which is written in (maybe) C together, is very good.

Currently Lua is *the* leading scripting language in video games. For Example World of Warcraft and Angry Birds uses
Lua and Lua won Awards because of this fact.

== What is Go(lang)?

Go aka. Golang is a programming language which was created 2009 from Google. The aim of go is not to be a embeddable
script language like Lua. It is also based on object-oriented and functional programming but these will combined with
a few new concepts (not really new some of them for the 70´s).

Google created with go a language which should handle the new challenges which came with the big cloud hipe and its
requirements.

Go should be:

- Compiled (cross compiler for OS: Mac, Windows, Linux and CPU: ARM, x86 + Amd64)
- Static type system with runtime support (Reflection, Dynamic Types)
- Static linker (Single Binary) -> Ideal for Docker containers
- Focus on fast compile times (the entire Go codebase compiles in <10 seconds)
- Simple (less keywords like C - 25/32) (what the hack is Simple???)
- Object-oriented, Functional, Parallel, Modular (vgo) and Versioned

These concepts was rounded which the concepts of Hoare´s CSP (1978) and Dijkstra´s guarded commands (1975). To get rid
of the heavy Concurrent approach of threads and think in this way.


== Small Overview/Comparison Go vs Lua

|===
|Feature |Go |Lua

|Multiple Projects
|Yes
|Yes

|Target audience
|Cloud computing, Web Development, App developer, Distributed Systems, Embedded system, Systems Programming
|Embedded system, Game developer industry

|Release Date
|2009
|1993

|Typing
|Static
|Dynamic

|Programming paradigm
|Concurrency Oriented, Object-oriented, Imperative programming, reflective
|Imperative programming, Object-oriented, Functional, Metaprogramming

|Supported VCS
|Any
|Git

|Embeddable
|Yes
|Yes

|Asynchronously
|Goroutines, Channels, Multi-Way cconcurrent control, Locks (Usually not needed!)
|Coroutines

|Exception Handling
|panic/recover
|Lua ends the current chunk and returns to the application pcall (like try/catch)

|Public/Private
|Implicit by default by Spelling/Writing
|Privacy by Local Variables or keep Objects/Tables in Closure

|Objects
|By Embedding and thou interfaces
|Tables

|Interfaces
|Yes
|No

|Compiled
|Yes
|Yes

|Inheritance
|Multiple by Interfaces
|Multiple Prototyping

|===

== Typing

One of the biggest differences between Lua an Go is typing. Lua is a dynamic types scripting language and Go on the
other hand is a simplified static typed language. Both concepts has it´s pros and cons and won´t discussed in this
article (These should be done of fanboys on conventions, talks and papers). These article shows a high look on the
concepts and how it is done in the languages.

== Assignment of Variables

Lua and Go allows multi assignment like:

    a,b = 1,2   // Lua
    a,b := 1,2  // Go - uses ':=' to declare and set values

Very interesting on this example is that Go *knows* the type of the variable by declaring it with a value. This could
also be done explicit by:

    a int
    a = 1

but is is still static.


Multi assignment allows funny things like to swap without a swap function

    a,b = b,a

or to receive multiple return values of a function without complicate handling (Exception Handling)

    result, error = f()   // Lua
    result, error := f()  // Go


=== Dynamic Typing

with dynamic typing you could but different values into one variable (of course not in the same time)

    a = 1
    a = "eins"
    a = f()
    ...

by static typing in go this is not possible

    a,b = 1,2  -- will work. go "knows" that a and b are integers
    a = "eins" -- will throw an exception. TypeError

casts must done explicitly like

    arr_1 := []any{2, 3, 4}
    a = 1
    a = a + arr_1[0].(int)
    or
    arr_2:= []int{1, 2, 3}
    b = 2 + arr_2[0]

should variables be declared before use they must also declared with typing

    b int
    c string
    a = 1 -- works fine
    b = 2 -- will also work
    c = 3 -- will occure an error

This will also effect Function declarations

*Go*

    func foo (a string, b int) string{
        return "Some Value"
    }

    type Any interface{}
    func foo_2(a Any, b Any) Any{
        x string
        b int
        x = a.(string)
        y = b.(int)
        return "Some Value"
    }
    result string
    result = foo_2("Some", 2).(string)


these example shows that the function params could only be string for a and an integer for b. Foo
must return a string. In the second example you have to cast the params and return value to fit
the correct type.
Main benefit is that you use always the correct type and at last during compiling errors will occured
and during runtime. This prevents for deploy errors in code. And it helps a lot for readability and
reuse functions. All the time you now what you need to call functions and which return you will get
after calling.

Lets have a look on Lua

    function foo (n)
        n = n or 1
        n + 1
        return n
    end

In this example you could not answer the questions:
- Which type has the parameter?
- Will you return something? And which type will it have?
- Must the parameter be set?

That's not really objective. There still exist documentation and the function it self shows what it needs.
But you don´t have compiler or Ide support for these kind of functions. Should foo be called like
foo("abc") it will occurs an invalid-type-exception during runtime and in worst case the programme will
break.
One of the main benefits of dynamic typing is it is much easier to write you dont care about expilict
typing. Code is much smaller and the most time the developer know which types he uses or maybe he doenst
care. take a look at anonymos functions you call theme in a defined enviroment were you know the types.
So why should the types explicit (again!) defined?








== Scope / Values References / Functions

go hat lexical block and universe block S46. in Go-buch :)

== Function Nested
    function foo(x)
        function p(y)
            print(y)
        end
        p(2*x)
    end

== anonymous Functions
    add = (function (x,y) return x+y end)

Functions are First-Class Values
Functions can be stored in variables and data structures
Can be passed as arguments to and returned by other functions (higher-order functions)
They can called anywhere in a program

== Lexical Scoping

Unlike global variables, local variables have their scope limited to the block where they are
declared. A block is the body of a control structure, the body of a function, or a chunk
(the file or string with the code where the variable is declared).

That is the same as for functions, so we could create typical closures like

 function sequence ()
      local i = 0
      return function ()
               i ++
               return i
             end
 end

= importing of Modules
lua

    local m = require "math"
    print(m.sqrt(10))

maybe to dynamic you cant check if there really math. there could be every expression

go

    import "fmt"
    explicites angeben der pfade
    Groß kleinschreibung sonst keine zugriffsmodifcatoren???

== eval

lua doesnt have eval function like js it has a load function (historical reason)
load separated compilation from execution
load is a pure function
any code always runs inside some function

- we can declare local variables which naturally work like static variables for the functions inside the chunk
- chunks can return values

    function eval (code)
        -- compiles source 'code' and executes the result
        return load(code)()
    end

= Closures
 function sequence ()
      local i = 0
      return function ()
               i ++
               return i
             end
    end


= generic for
 for k, v in pairs(t) do
    print(k, v)
 end

 for <var-list> in <exp-list> do
      <body>
  end

https://www.lua.org/pil/7.1.html

= Interfaces?? / Objects

The table type implements associative arrays. An associative array is an array that can be indexed not only with numbers,
 but also with strings or any other value of the language, except nil. Moreover, tables have no fixed size; you can add
 as many elements as you want to a table dynamically. Tables are the main (in fact, the only) data structuring mechanism
  in Lua, and a powerful one. We use tables to represent ordinary arrays, symbol tables, sets, records, queues, and
  other data structures, in a simple, uniform, and efficient way. Lua uses tables to represent packages as well. When we
   write io.read, we mean "the read entry from the io package". For Lua, that means "index the table io using the string
    "read" as the key".

Tables in Lua are neither values nor variables; they are objects. If you are familiar with arrays in Java or Scheme,
then you have a fair idea of what we mean. However, if your idea of an array comes from C or Pascal, you have to open
your mind a bit. You may think of a table as a dynamically allocated object; your program only manipulates references
(or pointers) to them. There are no hidden copies or creation of new tables behind the scenes. Moreover, you do not have
 to declare a table in Lua; in fact, there is no way to declare one. You create tables by means of a constructor
  expression, which in its simplest form is written as {}:

first-class functions + tables ~ objects
syntactical sugar for methods - handles self

a:foo(x) => a.foo(a,x)

    function a:foo(x)
        ...
    end

=>

    a.foo = function(self,x)
        ...
    end

Lua doesn´t need Interfaces in the usual meaning. An interface says that an Object which includes an Interface has specific
functions, methods or properties. But in Lua there are no Objects like in Java. But OO Programming way is possible if
functions and tables are seen as an Object

*Go*

interfaces vai

    type x interface{
    }

= Asynchrounes /Synchrones Routinen vs Coroutines

Queue in Lua. Warten, noch mal naachschauen

A coroutine is similar to a thread (in the sense of multithreading): a line of execution, with its own stack, its own
local variables, and its own instruction pointer; but sharing global variables and mostly anything else with other
 coroutines. The main difference between threads and coroutines is that, conceptually (or literally, in a multiprocessor
  machine), a program with threads runs several threads concurrently. Coroutines, on the other hand, are collaborative:
   A program with coroutines is, at any given time, running only one of its coroutines and this running coroutine only
    suspends its execution when it explicitly requests to be suspended.

Coroutine is a powerful concept. As such, several of its main uses are complex. Do not worry if you do not understand
some of the examples in this chapter on your first reading. You can read the rest of the book and come back here later.
 But please come back. It will be time well spent.
(zusammenstampfen. alles geklaut)

coroutine has 3 states: suspended, running, dead
it can stores in a variable and like:

    co = coroutine.create(function ()
           for i=1,10 do
             print("co", i)
             coroutine.yield()
           end
         end)

Now, when we resume this coroutine, it starts its execution and runs until the first yield:

    coroutine.resume(co)    --> co   1

If we check its status, we can see that the coroutine is suspended and therefore can be resumed again:

    print(coroutine.status(co))   --> suspended

This can be done till the for-loop is ending. than the state of the coroutine is dead. and it could not longer be called
without an exception.

coroutines are a kind of collaborative multithreading. there a not constructed as real multithreading like go-routines.
While a coroutine is running, it cannot be stopped from the outside
However, with non-preemptive multithreading, whenever any thread calls a blocking operation, the whole program blocks
until the operation completes.

for exsacmple downloading different files trou http. it could be downloaded in sequence (tooks a long time)
or is there currently no data available the coroutines could yield and another coroutine could run and so own.

 function download (host, file)
      local c = assert(socket.connect(host, 80))
      local count = 0    -- counts number of bytes read
      c:send("GET " .. file .. " HTTP/1.0\r\n\r\n")
      while true do
        local s, status = receive(c)
        count = count + string.len(s)
        if status == "closed" then break end
      end
      c:close()
      print(file, count)
    end

    function receive (connection)
      connection:timeout(0)   -- do not block
      local s, status = connection:receive(2^10)
      if status == "timeout" then
        coroutine.yield(connection)
      end
      return s, status
    end

The next function ensures that each download runs in an individual thread:

    threads = {}    -- list of all live threads
    function get (host, file)
      -- create coroutine
      local co = coroutine.create(function ()
        download(host, file)
      end)
      -- insert it in the list
      table.insert(threads, co)
    end

*Go*

Follows totally other concepts of async/sync/Threading
Go supports Multithreading in form of goRoutines which a very leight and multiplext. This means on and the same goroutine
could be executied on several OS threads. This offers a lot of new opportunities. This goroutines in the regular way
without blocking any variable like know from Java. goroutines Communicate to pass data from one routine into another.
Important to understand is that a Goroutine is not a Thread.
It Supports

- concurrent execution (goroutine)
- synchronization and messaging (channels)
- multi-way concurrent control (select)
- low level blocking primitives (locks) - Usually not needed!


= Pointers?

*LUA*

Lua doesn´t offer Pointers (of course internal it uses references to memory) depending on the data-type there were
reference or values copied. Lua handles allocation and deallocation of strungs and other objects

 Or as some people like to put it; all types are passed by value, but function, table, userdata and thread are reference types.

string is also a kind of reference type, but is immutable, interned and copy-on-write - it behaves like a value type,
but with better performance.

*Go* does offer Pointer to give the developer full control

= Map/Reducer sample

The "canonical" example of a function that takes another function as a parameter is map. Unfortunately map does not come with Lua, so we'll have to code it ourselves.

function map(func, array)
  local new_array = {}
  for i,v in ipairs(array) do
    new_array[i] = func(v)
  end
  return new_array
end

This is a simple map implementation that only works with one array. But it works well:

> return table.concat(map(double, {1,2,3}),",")
2,4,6

A more complex map implementation that works with more than one array is possible:

function mapn(func, ...)
  local new_array = {}
  local i=1
  local arg_length = table.getn(arg)
  while true do
    local arg_list = map(function(arr) return arr[i] end, arg)
    if table.getn(arg_list) < arg_length then return new_array end
    new_array[i] = func(unpack(arg_list))
    i = i+1
  end
end


REDUCER
function foldr(func, val, tbl)
     for i,v in pairs(tbl) do
         val = func(val, v)
     end
     return val
 end

 -- reduce(function, table)
 -- e.g: reduce(operator.add, {1,2,3,4}) -> 10
 function reduce(func, tbl)
     return foldr(func, head(tbl), tail(tbl))
 end

 The pairs function, which iterates over all elements in a table, is similar, except that the iterator function is the next function, which is a primitive function in Lua:

     function pairs (t)
       return next, t, nil
     end



= Exception handling
*lua*
anonymous functison wiht lexical scoping again error handling could use variables form current function usw.
simple semantic you need only 2 functions - there you could see how functional programming is a major part of lua.
simple to interface with other languages

bad
verbose
body cannot return/break
try is not cost-free (but not very expencive)


    local ok, err = pcall(function() <block/error> end) -- protacted Call

    if not ok then
        <exception code>
    end

*Go*

Go includes 2 Error Strategies

the first one is for functions which could return an error which a programmer can´t handle/controle
like http reject

    ok, err = http.Get(url)
    if err != nil {
        return nil, err // error handling
    }

this example shows a common case in which the program should not crash. we only need to handle the
error, maybe throu calling the Get again or what ever.

the second handling is the panic-Function which is reserved for states, behaviour of the program
which absolutly unnormal and need the handled explicitly or will crash it.

    func NewRational(numerator int, denominator int) Rational {
	    if denominator == 0 {
	    	panic("division by zero")
	    }
	    ...
	}
	a := NewRational(1,0)

    func Parde(input string) (s *Syntax, err error){
        defer func() {
            if p:= recover(); p != nil {
                err = fmt.Errorf("internal error: %v", p)
            }
        }()
        // .. parser ..
    }

here you could the that a rational would created which has 0 as a denominator which is absolutely
nonsense and the system could not handle this. -> panic will called and the caller has to handle that
or the program will break


go includes by design the pcall from lua. The aprouch that if the expected behavior of a function
could be a failure that function has an additional result. This saves performance by calling wrapping
the function in a pcall.
The Panic mechanism allows depending of the programmers intention to recover the Program. But sometimes
it is the right response to panic an maybe break the program. These second Strategy is if you want to
write the exaption in a logfile or cleanup after the panic or what ever.




== CHEAT Sheet

https://powerman.name/doc/asciidoc

== Talk about LUA Functions
https://www.youtube.com/watch?v=wdRGOE1N-FA
https://pragprog.com/magazines/2013-05/a-functional-introduction-to-lua
https://www.lua.org/pil/6.html

Quellen
https://www.lua.org
https://www.youtube.com/watch?v=wdRGOE1N-FA (Talk von LUA in Moskau by Roberto Ierusalimschy)
http://vschart.com/compare/lua/vs/go-language
Programming in Lua by Roberto Ierusalimschy, Lua.org, December 2003
The Go Programming Language Donovan, Kernighan
Lecture of Johannes Weigend at Technical University of Applied Sciences Rosenheim (There i stole a lot of the go part)
https://www.youtube.com/watch?v=f6kdp27TYZs&feature=youtu.be&t=1 (Rob Pike Google I/0 2012 - Go Concurrency Patterns)