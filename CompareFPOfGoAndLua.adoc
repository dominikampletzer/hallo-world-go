= Compare Functional Programming of Go and Lua
:toc:


== Introduction

This article compares two programming languages - *Lua* and  *Go(lang)*. It covers the most important concepts of these
two languages.

- It will start with a high overview and what and for which use case the languages was designed
- Deeper dive into Typing of both
- Objects in Lua and explain tables
- Show how functions and Exception handling works
- Jump into Goroutines and Coroutines, which are made for different use cases

== What is Lua?

Lua is a programming language which was released, designed, implemented and maintained 1993 by PUC-Rio,
the Pontifical Catholic University of Rio de Janeiro in Brazil. Till version 4 it was under the
BSD-Licence since Version 5 its under MIT-Licence.

In the first Version Lua was created as a library. During time and further developing it grows to a programming language.

Lua creators goal is to create a powerful, efficient, lightweight and embeddable scripting language. It based of
concepts of procedural, object-oriented , functional and data-driven programming, also on data description.

Lua is a very small and embeddable language which is focused on portability, size, scripting and simplicity (Never did
any creator of a language sad, he or she wants to create a complex and unknowable language :) ). Because of this it has
a small footprint, is easy to embed in platforms which support a standard C compiler and it is a scripting language it
is dynamically typed.

It´s easy to create a program written in two languages with Lua. Lua could sean as the glue which holds the hard parts
of a program ( maybe written in _C_) together.

Currently Lua is *the* leading scripting language in video games. For Example World of Warcraft and Angry Birds use
Lua. Because of the popularity of Lua it won´s Awards like the _Front Line Award 2011_.

== What is Go(lang)?

Go aka. Golang is a programming language which was created 2009 by Google. The aim of go is not to be an embeddable
script language like Lua. It is also based on object-oriented and functional programming but these will combined with
a few new concepts. New only relatively spoken, for some of these concepts from the 70´s. But why use such old stuff?
In the 70´s that concepts was only theoretical without a use case. That changed with multi core cpu´s, distributed
computing and the whole cloud stuff :).

With Go Google created a language which should handle the new challenges which came with the big cloud hype and its
requirements.

These are the requirements Google wanted to meet:

- Compiled (cross compiler for OS: Mac, Windows, Linux and CPU: ARM, x86 + Amd64)
- Static type system with runtime support (Reflection, Dynamic Types)
- Static linker (Single Binary) -> Ideal for Docker containers
- Focus on fast compile times (the entire Go codebase compiles in <10 seconds)
- Simple (less keywords like C - 25/32) (what the hack is Simple???)
- Object-oriented, Functional, Parallel, Modular (vgo) and Versioned

These concepts was rounded with the concept of Hoare´s CSP (1978) and Dijkstra´s guarded commands (1975). To get rid
of the heavy concurrent approach of threads and think in this way.

That challanges are solved by Go, and it is now part of the cloud native landscape.


== Small Overview/Comparison Go vs Lua

|===
|Feature |Go |Lua

|Multiple Projects
|Yes
|Yes

|Target audience
|Cloud computing, Web Development, App developer, Distributed Systems, Embedded system, Systems Programming
|Embedded system, Game developer industry

|Release Date
|2009
|1993

|Typing
|Static
|Dynamic

|Programming paradigm
|Concurrency Oriented, Object-oriented, Imperative programming, reflective
|Imperative programming, Object-oriented, Functional, Metaprogramming

|Supported VCS
|Any
|Git

|Embeddable
|Yes
|Yes

|Asynchronously
|Goroutines, Channels, Multi-Way cconcurrent control, Locks (Usually not needed!)
|Coroutines

|Exception Handling
|panic/recover
|Lua ends the current chunk and returns to the application pcall (like try/catch)

|Public/Private
|Implicit by default by Spelling/Writing
|Privacy by Local Variables or keep Objects/Tables in Closure

|Objects
|By Embedding and by interfaces
|Tables

|Interfaces
|Yes
|No

|Compiled
|Yes
|Yes

|Inheritance
|Multiple by Interfaces
|Multiple Prototyping

|===

== Typing

One of the biggest differences between Lua an Go is typing. Lua is a dynamic types scripting language and Go on the
other hand is a simplified static typed language. Both concepts has it´s pros and cons and won´t discussed in this
article (These should be done of fanboys on conventions, talks and papers). These article shows a high look on the
concepts and how it is done in the languages.

=== Assigning Variables

Lua and Go allows multi assignment like:

    a,b = 1,2   // Lua
    a,b := 1,2  // Go - uses ':=' to declare and set values

Very interesting on this example is that Go *knows* the type of the variable by declaring it with a value. This could
also be done explicit by:

    a int
    a = 1

but is is still static.


Multi assignment allows funny things like to swap without a swap function

    a,b = b,a

or to receive multiple return values of a function without complicate handling (Exception Handling)

    result, error = f()   // Lua
    result, error := f()  // Go


=== Dynamic Typing - Lua

Languages with dynamic typing check the type during runtime. This means it is not important or the programmer has to
care about which variable holds which type. It could be said a variable could handle values of different types
(of course not in the same time but in the variable lifecycle). In the next example it will be clearer:

    a = 1
    a = "eins"
    a = f()
    ...

There is no need for casting to get an int into a double/float or what ever. Sounds nice. But there is a lot for the
programmer to do, if he wants build a stable program. He has to check his variable during input, handling and output.
He or she can´t be sure is that variable really numeric value or only a string, which only looks numeric. Even worse if
you add to an int an object because in both variable was an int but during runtime it was overridden by any object or
what ever.

On the other hand if you know there are only correct types and variables, it is very easy to handle them. The casting
operation always works correct if needed, the code looks very clean, and one can handle different types the same way.

=== Static Typing - Go

For *Go* is it very important to have static typing with a lot of syntactic sugar.  In Go one can’t assign to a variable
in different types (Why should someone do that? Its much easier to create a new variable).

    a := 1      // a will declared as a variable from the type integer an gets the value

    // equivalent to
    a int
    a = 1

    a = "one" // will occur a panic Type Error

These concept makes it very easy for developers to know which values he or she needs for calling functions or handle
return values. Because every time it is totally clear which variables, params or return values has to be handled.

Of course static typing have problems or ugly sides. Should there be an Array of Objects and it is totally clear that
only Integer values are in it you have to cast them explicitly.

    arr_1 := []any{2, 3, 4}
    a ;= 1
    a := a + arr_1[0].(int)
    or
    arr_2 := []int{1, 2, 3}
    b := 2 + arr_2[0]

Another important thing to say is that if one declares variables one must also declare the type. It´s not a big deal,
but it´s good to know and a kind of syntactic sugar.

The static approach has also effects on functions. The parameters can only be declared with types. Because of this,
should the parameter not be clear during creating the function or to use in several ways you have to cast explicit like:

    func foo (a string, b int) string{
        return "Some Value"
    }
    type Any interface{}
    func foo_2(a Any, b Any) Any{
        x string
        b int
        x = a.(string)
        y = b.(int)
        return "Some Value"
    }
    result string
    result = foo_2("Some", 2).(string)


The example shows that the function params could only be string for _a_ and an integer for _b_. _foo_ must return a
string. In the second function you have to cast the params and return value to fit the correct type. Main benefit is
that the developer can easily see the correct type and use it in the correct way. IDE´s and at last the compiler are
able to find type errors. In worst case function _foo_2_ could still occur an type error during runtime. Go allows type
save casts but if it will cast in the wrong type an error occur.

Static typing helps developer to prevent errors. But if it helps to understand the code and supports, readability depend
on the developer who uses it.

Let’s take a look on Lua functions to see how it will look there:

    function foo (n)
        n = n or 1
        n + 1
        return n
    end

Without saying which concept is better, dynamic or static could you answer following questions?

- Which type has the parameter? Or how should _foo_ be called?
- Will you return something? And which type will it have?
- Must the parameter be set?

That’s not really fair. There still exists documentation and the function parameter naming could show if it’s needed and
which type is to use. But you don´t have compiler or IDE support for this kind of typing.

Should foo be called like _foo("abc")_ it will occur an invalid-type-exception during runtime and in the worst case the
program will break.

One of the benefits of dynamic typing is it is much easier to write, you don´t care about explicit typing and variables
could reused for what the developer needs not for what it is declared. Code can be much smaller and during developing
the developer know which types he uses if he even cares . Anonymous functions are called in an explicit context where
the types are known.  So why should there be types defined? There is only one way to use and it´s absolute clear!

== Objects in Lua (Go Objects will discussed in other articles)

Objects in Lua are called _Tables_. They are a kind of associative array. These array store different kinds of values.
That values can be indexed by number or string. Tables have no fixed size known from other languages and could grow
dynamically during runtime. Take a look of how _Tables_ could look:

    TableA = { 1, "One", boolean}
    print(TableA[2])                                    // One - Lua starts to index by 1
    TableB = { first = "ONE", second= 2 , third = false}
    print(TableA["second"])                             // 2
    TableC = {first = 1, second = 2, 3}
    print(TableC["first"}, TableC.second, TableC[1])    // 1 2 3 - Because 3 is the first none named value!!!

This data structure will be used for every structure in Lua like ordinary arrays, symbol tables, sets, records and queues.

Tables in Lua are neither values nor variables, they are objects. As such there are no hidden copies or creation of new
tables behinde the scenes, the program manipulates tables by references.

If there is the need for a new table you can just create it like in the example above. There is no need for constructor.

To get the same behaviour as for object or classes in other languages the tables has to be extended with first-class
functions. That could be done in several ways like:

    LanguageTable = {
        de = "", en = "",
        New = function()
            helloT = {}
            for k, v in pairs(HelloTable) do
                helloT[k] = v
            end
            return helloT
        end,
        german = function(param)
            print(param.de)
        end,
        english = function(param)
            print(param.en)
        end
    }
    a = LanguageTable.New()
    a.de = "Servus"
    a.en = "HI"
    a.german(a)                  // Servus
    a.english(a)                 // HI

or with more syntactical sugar and more functionality like metatable

    LanguageTable = {
        de = "", en = "",
        mt = {},
        New = function()
            helloT = {}
            setmetatable(helloT, LanguageTable.mt)   // setmetatable() came with Lua
            return helloT
        end,
        german = function(self) // convention
            print(self.de)
        end,
        english = function(self)
            print(self.en)
        end
    }
    LanguageTable.mt.__eq = function(lt1, lt2) // __eq stands for operator Equals
       return lt1.de == lt2.de and lt1.en == lt2.en
    end
     LanguageTable.mt.__index = LanguageTable   // allows to call functions from super.

Lets have a look on the example before showing it how it is used. In the _New/Constructor_-Function now it appears a
_setmetatable_-Function which came with Lua and assign that table to a new created table which we return. That is used
by overloading the operations during the ____-Notation of _equals_ and _index_. During equals is a kind of boring,
because is is a simple equals implementation, _index_ is very interesting it shows how _super()_ from other languages
is included. _index = LanguageTable_ sad, should there be no value in the current object, take value from _LanguageTable_.

 a = LanguageTable.New()
 a.de = "Servus"
 a.en = "HI"
 a:german()                  // Servus - :-Notation passes self as parameter
 a:english()                 // HI
 b = LanguageTable.New()
 b.de = "Hallo"
 b.en = "Hello"
 print(a == b)              // false
 c = LanguageTable.New()
 c.de = "Hallo"
 c.en = "Hello"
 print(b == c)              // true

The usage shows a few little differences. With the _:_-Notation there is no need to pass the table into the function.
The Equals operator works now for tables. And _index_ allows to call _german_ and _english_ from the template table.

There is still a lot to say about tables in Lua but for this article it is enough.

=== More Characteristics of Lua and Go

=== Importing Modules

In Lua the creators say with a smily maybe the import is maybe to dynamic. The linking to the "math"-library is
never be checked. During execution it is there or the program throws an error.

    local m = require "math"
    print(m.sqrt(10))

Go has static linking. Special is that the whole Path the the imported Package/Library has to be written. If the
developer uses a state of the art IDE, that IDE handles imports for the Developer so he hasn´t to care.

    import "fmt"
    fmt.println("Hello World")

=== Pointers / References / Call By Value

*Lua* don´t offer Pointers (of course internal it uses references to memory) depending on the data-type there were
reference or values copied. Lua handles allocation and deallocation of strings and other objects.

Or more simple all types are passed by value, but function, table, userdata and thread are reference types. An
exception is String it is immutable and will handled as a reference to a new created string. So it has same behaves
like a value type, but with better performance. (i have no idea why better performance)

*Go* offer Pointer and all functionality which came with that opportunity.

== Functions

Now the basics are clear. Let’s take a deeper dive into the functions of both languages.

=== Scope

*Lua* uses lexical scoping this means unlike global variables, local variables have their scope limited to the block
where they are declared. A block is the body of a control structure, the body of a function or a chunk (the file or
string with the code where the variable is declared). That´s the same for functions, so we could create typical closures
like:

    function sequence ()
        local i = 0
        return function ()
            i ++
            return i
        end
    end

*Go* has nearly the same behaviour except global variables, Go doesn´t contain them. The scoping of Go is called lexical
blocks, which means the same as Lua´s lexical scope. The syntactic block is a sequence of statements enclosed in braces
that surround the body of a function or loop. There is a lexical scope for the entire source code, called the universal
scope: For each package, file, function, loop, switch, switch-case, select and of course for each lexical scope. Imports
are in the file level scope. Closures in Go look nearly the same as in Lua:

    func sequence() func() int  {
    	i := 0
    	return func() int {
    		i++
    		return i
    	}
    }

As we can see  both can handle closures and functions as first class values/citizens. Which means you can treat
functions as values. Functions could be function parameter, return values (higher-order functions) or stored in variables.

=== Function Nesting

As expected both languages have function nesting like we see in *Lua*

    function foo(x)
        function p(y)
            print(y)
        end
        p(2*x)
    end

and *Go*

    func foo(x int) {
    	b := func(y int) {
    		fmt.Println(y)
    	}
    	b(2 * x)
     }

=== Anonymous Functions

Beside function nesting there are in both languages anonymous functions

    add = (function (x,y) return x+y end)   // Lua
    add := func(x int, y int) int {         // Go
    		return x + y
    	}


=== Example Map-Function

The "canonical" example of a function that takes another function as a parameter is _map_. Unfortunately _map_ does not
come with *Lua*, so we'll have to code it ourselves.

    function map(func, array)
        local new_array = {}
        for i,v in ipairs(array) do // ipairs returns simple said the key and value
            new_array[i] = func(v)
        end
        return new_array
    end

This is a simple map implementation that only works with one array. But it works well:

    return table.concat(map(double, {1,2,3}),",") // 2,4,6

Its very funny that *Go* same as Lua does not include a map function. So to compare code it ourselves.

    func Map(foo func(interface{}) interface{}, arr []interface{}) interface{} {
    	temp := new([]interface{})
    	for _, v := range arr {
    		*temp = append(*temp, foo(v))
    	}
    	return temp
    }

In the Go example there is to see that interface{} is very often used to use Map with every type. That looks very ugly
and does not support the developer in how the function should be used. To use it more explicit and with the common
_Object.Function()_-Notation for using functions on Objects Map could written for a type explicit.

    func (s *SomeType) Map(mapperFunction AnyInterface) SomeReturnValue {
    	for i, el := range s.data {
	    	s.data[i] = mapperFunction(el)
	    }
	return s
    }
    s := make(SomeType)
    s.Map(AnyFunction)

== Exception handling

*Lua* uses function nesting for its error handling. The _pcall_-Function (Protacted Call) tooks a function as parameter
and calls that function. _pcall_ returns two values a ok-Value should all be ok :) and a second value with the error
message should during calling the function an error occur. This is a very good example how function nesting and multi
assignment work.

    local ok, err = pcall(function() <block/error> end)
    if not ok then
        print(err) // error handling
    end

Simple semantic you need only 2 functions – this shows that functional programming is a major part of Lua.

For *Go* its nearly the same. For functions which it is usual to intend an error, like http calls, that function has to
return an error by design in error case. So there is no need wrapping functions into a _pcall_ like:

    ok, err := http.Get(url)
    if err != nil {
        fmt.println(err) // error handling
    }

this example shows a common case in which the program should not crash. we only need to handle the
error, maybe across calling the Get again or what ever.

The second handling strategy is for unexpected error the _panic_-Function which is reserved for _wrong_ states and
behaviour of the program. _Panic_ could be cached to maybe cleanup a Webserver, write into a logfile, stop the
program more controlled or maybe recover.

Panics could be thrown very easy.

	panic("42")

and similar simple cached

    func Parse(input string) (s *Syntax, err error){
        defer func() {                              // nearly same as finally
            if p:= recover(); p != nil {
                err = fmt.Errorf("internal error: %v", p)
            }
        }()
        // .. parser ..
    }

*Go* includes by design the _pcall_ from Lua. But the _pcall_ needs to be built into the functions as an expected
behaviour, as an additional return value. This is a better approach and has better performance wrapping every unsafe
function into a _pcall_. The Panic mechanism allows depending of the developers intention to recover the program. Do not
 forget sometimes it is the right response to panic and maybe break the program.

== Routinen vs Coroutines or Async and Threading

*Lua* offers coroutine which are similar to a the well known thread (in the sense of multithreading): a line of execution,
with its own stack, its own local variables, and its own instruction pointer; but sharing global variables and
mostly anything else with other coroutines. The main difference between threads and coroutines is that, conceptually
(or literally, in a multiprocessor machine), a program with threads runs several threads concurrently. Coroutines, on
the other hand, are collaborative: A program with coroutines is, at any given time, running only one of its coroutines
and this running coroutine only suspends its execution when it explicitly requests to be suspended.

A coroutine has 3 states: _suspended_, _running_, _dead_. It could be stored in variables and coroutines has
functionality to get its state, close, yield and creating them.

    co = coroutine.create(function ()
           for i=1,10 do
             print("co", i)
             coroutine.yield()
           end
         end)

Now, when we resume this coroutine, it starts its execution and runs until the first yield:

    coroutine.resume(co)    // 1

If the status will be checked it returns the _suspended_-state.

    print(coroutine.status(co))   --> suspended

This can be done till the for-loop is ending. Then the state of the coroutine will change to dead. It can no longer be
called without an exception.

For example downloading different files using http. It could be downloaded in sequence (tooks a long time)
or is there currently no data available the coroutines could yield and another coroutine could run and so own.

 function download (host, file)
      local c = assert(socket.connect(host, 80))// creates connection
      local count = 0                           // counts number of bytes read
      c:send("GET " .. file .. " HTTP/1.0\r\n\r\n")
      while true do
        local s, status = receive(c)
        count = count + string.len(s)
        if status == "closed" then break end
      end
      c:close()
      print(file, count)
    end

    function receive (connection)
      connection:timeout(0)                     // do not block
      local s, status = connection:receive(2^10)
      if status == "timeout" then
        coroutine.yield(connection)
      end
      return s, status
    end

The next function ensures that each download runs in an individual thread:

    threads = {}                                // list of all live threads
    function get (host, file)
      local co = coroutine.create(function ()   // create coroutine
        download(host, file)
      end)
      table.insert(threads, co)                 // insert into list
    end

Coroutines are a kind of collaborative multithreading. There a not constructed as real multithreading like Goroutines.
While a coroutine is running, it cannot be stopped from the outside! However, with non-preemptive multithreading,
whenever any thread calls a blocking operation, the whole program blocks until the operation completes.

For several applications this is not a problem, even better, it´s much easier. Developers have not to worry about
lock or unlock functions/variables. There can´t be synchronization bugs among threads. The only thing developers have to
care is to _yield_ and _resume_ coroutines to prevent deadlocks or let coroutines wait till the end of time.

*Go* on follows totally other concepts of async and threading. Go supports multithreading in form of Goroutines which
are very light and multiplext. This means a Goroutine could be executed on several OS threads. This concept offers the
opportunity to use all cores of a machine. This Goroutines in common do not use blocking. It is possible but unusual.
Goroutines uses communication to pass data from one routine into another. This method is inspired by Hoare´s CSP (1978)
and Dijkstra´s guarded commands (1975). In these concepts there is no need to share memory or variables to pass data
between Goroutines, they communicate to handle that. For these Go includes so called channels in which can be written or
read. Depending on the use case, with or without buffering. The default channel has no buffer size, so if a Goroutine
would write into a channel it waits for a receiver on the other side. Similar to that the receiver waits till someone
writes into the channel. With these simple rules routines can be synchronised.

    type Ball struct{ hits int }                    // Ball contains the number of hits.
    func main() {
        table := make(chan *Ball)
        go player("ping", table)
        go player("pong", table)
        table <- new(Ball)                          // game on; toss the ball
        time.Sleep(1 * time.Second)
        <-table                                     // game over; grab the ball
    }
    func player(name string, table chan *Ball) {
        for {
            ball := <-table
            ball.hits++
            fmt.Println(name, ball.hits)
            time.Sleep(100 * time.Millisecond)
            table <- ball
        }
    }

This example shows a lot. Start with definitions of unusual operators and reserved words:

-  _chan_ is the type of Channels
- _go_-command tells the machine that this should be started asynchronously  as an independent Goroutine. (very easy
syntax)
-  _some_value_ means to write _some_value_ into the channel
-  a = \<- _some_channel_ tooks the value from a channel

Lets look deeper into the example above.

- In the first line a struct is created which contains the hits (boring)
- The main-function creats a table which is a channel of Ball-Pointer
- Than two player-functions will launched. Both get a name and took a channel of Ball-Pointer. And start in a infinite
loop: wait to read from table, hit the ball, write the hits to the console, wait and write to the table channel.
- Now the game starts. The first message is written into the table channel (do not forget the two player-functions
are started and waiting for the first message to handle the ball)
- Wait
- Take a message from the channel (=> the two players both wait for a message at the table-channel but non will be there)
GAME OVER!

It is important to understand is that a Goroutine is not a Thread. It’s much more lighter and does not share variables
or memory. It passes data using channels. That needs new control structures like the _select_-Statement which is nearly
the same as usual _switch_-statements only for sequential Goroutine handling. And of course if it is needed Go offers blocking:

    var someThing sync.Mutex
    func BlockingExample() {
        something.Lock()
        defer something.Unlock()
    ...
    }

= Summary

Best to see in the _Goroutine vs Coroutine_ chapter. *Lua* and *Go* are made for different usage. *Lua* is made as an
embaddable lightweight dynamic script language and does a good job for that approaches. While *Go* as cloud programming
server language, optimized for the challenges of this discipline. It is lightweight static fast to compile
multi-threading concurrent language.

= Bibliography
== Web
https://www.lua.org
https://www.youtube.com/watch?v=wdRGOE1N-FA (Talk von LUA in Moskau by Roberto Ierusalimschy)
https://www.youtube.com/watch?v=f6kdp27TYZs&feature=youtu.be&t=1 (Rob Pike Google I/0 2012 - Go Concurrency Patterns)
https://pragprog.com/magazines/2013-05/a-functional-introduction-to-lua
http://vschart.com/compare/lua/vs/go-language

== Books
The Go Programming Language Donovan, Kernighan
Programming in Lua by Roberto Ierusalimschy, Lua.org, December 2003

== Lecture
Johannes Weigend at Technical University of Applied Sciences Rosenheim (There i stole a lot of the Go stuff)

by Dominik Ampletzer
