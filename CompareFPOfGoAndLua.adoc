= Compare Functional Programming of Go and Lua

by Dominik Ampletzer

== Introduction

This article compares two programming languages - *Lua* and  *Go(lang)*. It covers the most important concepts of these
two languages. Object orientated aspects will be handled in separate articles. There is a lot to say about all the explicit
concepts and still problems to compare totally different concepts. Here to see it is more done like *Lua* make it this way and
*Go* that way.

Ok. That`s enough blabla. Start with Facts :)

== What is Lua?

Lua is a Programming Language which was released, designed, implemented and maintained 1993 by PUC-Rio,
the Pontifical Catholic University of Rio de Janeiro in Brazil. Till Version 4 it was under the
BSD-Licence since Version 5 its under MIT-Licence.

In the first Version Lua was created as a library. Further it grows to a one language.

Lua creators goal is to create a powerful, efficient, lightweight and embeddable scripting language. It based of
concepts of procedural, object-oriented , functional and data-driven programming, also on data description.

Lua is a very small and embeddable language which is focused on portability, size, scripting and simplicity (nobody
say they create a complicate programming language ...). Because of this it has a small footprint, is easy to embed in
platforms which support a standard C compiler and it is a scripting language it is dynamically typed.

It´s easy to create Program written in two languages with Lua. The comparison, that Lua is the glue which holds the
hard parts of the Program which is written in (maybe) C together, is very good.

Currently Lua is *the* leading scripting language in video games. For Example World of Warcraft and Angry Birds uses
Lua and Lua won Awards because of this fact.

== What is Go(lang)?

Go aka. Golang is a programming language which was created 2009 from Google. The aim of go is not to be a embeddable
script language like Lua. It is also based on object-oriented and functional programming but these will combined with
a few new concepts (not really new some of them for the 70´s).

Google created with go a language which should handle the new challenges which came with the big cloud hipe and its
requirements.

Go should be:

- Compiled (cross compiler for OS: Mac, Windows, Linux and CPU: ARM, x86 + Amd64)
- Static type system with runtime support (Reflection, Dynamic Types)
- Static linker (Single Binary) -> Ideal for Docker containers
- Focus on fast compile times (the entire Go codebase compiles in <10 seconds)
- Simple (less keywords like C - 25/32) (what the hack is Simple???)
- Object-oriented, Functional, Parallel, Modular (vgo) and Versioned

These concepts was rounded which the concepts of Hoare´s CSP (1978) and Dijkstra´s guarded commands (1975). To get rid
of the heavy Concurrent approach of threads and think in this way.

That challanges are solved by Go and it is a part of the cloud native landscape.


== Small Overview/Comparison Go vs Lua

|===
|Feature |Go |Lua

|Multiple Projects
|Yes
|Yes

|Target audience
|Cloud computing, Web Development, App developer, Distributed Systems, Embedded system, Systems Programming
|Embedded system, Game developer industry

|Release Date
|2009
|1993

|Typing
|Static
|Dynamic

|Programming paradigm
|Concurrency Oriented, Object-oriented, Imperative programming, reflective
|Imperative programming, Object-oriented, Functional, Metaprogramming

|Supported VCS
|Any
|Git

|Embeddable
|Yes
|Yes

|Asynchronously
|Goroutines, Channels, Multi-Way cconcurrent control, Locks (Usually not needed!)
|Coroutines

|Exception Handling
|panic/recover
|Lua ends the current chunk and returns to the application pcall (like try/catch)

|Public/Private
|Implicit by default by Spelling/Writing
|Privacy by Local Variables or keep Objects/Tables in Closure

|Objects
|By Embedding and by interfaces
|Tables

|Interfaces
|Yes
|No

|Compiled
|Yes
|Yes

|Inheritance
|Multiple by Interfaces
|Multiple Prototyping

|===

== Typing

One of the biggest differences between Lua an Go is typing. Lua is a dynamic types scripting language and Go on the
other hand is a simplified static typed language. Both concepts has it´s pros and cons and won´t discussed in this
article (These should be done of fanboys on conventions, talks and papers). These article shows a high look on the
concepts and how it is done in the languages.

=== Assigning Variables

Lua and Go allows multi assignment like:

    a,b = 1,2   // Lua
    a,b := 1,2  // Go - uses ':=' to declare and set values

Very interesting on this example is that Go *knows* the type of the variable by declaring it with a value. This could
also be done explicit by:

    a int
    a = 1

but is is still static.


Multi assignment allows funny things like to swap without a swap function

    a,b = b,a

or to receive multiple return values of a function without complicate handling (Exception Handling)

    result, error = f()   // Lua
    result, error := f()  // Go


=== Dynamic Typing - Lua

Languages with dynamic typing check the type during runtime. This means it is not important or the programmer has to
care about which variable holds which type. It could be said a variable could handle values of different types
(of course not in the same time but in the variable lifecycle). In the next example it will be clearer:

    a = 1
    a = "eins"
    a = f()
    ...

There is no need for casting to get an int into a double/float or what ever. Sounds nice. But there is a lot for the
programmer to do, if he wants build a stable program. He has to check his variable during input, handling and output.
He can´t be save is that variable really numeric value or only a string, which only looks numeric, or worse if you
add to an int an object because in both variable was an int but during runtime it was overridden by any object or what
ever.

On the other hand if you know there a only correct types and variables it is very easy to handle them, there is no casting
operator are always work correct, code looks very clean, and you could handle different types the same way.

=== Static Typing - Go

For Go is it very important to have static typing with a lot of syntactic sugar. In go you could not assign to variable
different types (why should someone do that?).

    a := 1      // a will declared as a variable from the type integer an gets the value

    // equivalent to
    a int
    a = 1

    a = "one" // will occur a panic Type Error

These concept makes it very easy for developers to know which values he needs for calling functions or handle return
values. Because every time it is totally clear which variables, params or return values has to be handled.

Of course static typing has problems or ugly sides. Should there be an Array of Objects and is is totally clear that
only Integer values are in it you have to cast them explicitly.

    arr_1 := []any{2, 3, 4}
    a ;= 1
    a := a + arr_1[0].(int)
    or
    arr_2 := []int{1, 2, 3}
    b := 2 + arr_2[0]

Another important thing to say is that if you declare variables you have also declare the type. It´s not a big deal,
but it´s good to know.

The static approuch has also effects on functions. The parameters could only be declared with types. And because of
this, should the parameter not be clear during creating the function or to use in serveral ways you have to cast
explicit like:

    func foo (a string, b int) string{
        return "Some Value"
    }
    type Any interface{}
    func foo_2(a Any, b Any) Any{
        x string
        b int
        x = a.(string)
        y = b.(int)
        return "Some Value"
    }
    result string
    result = foo_2("Some", 2).(string)


The example shows that the function params could only be string for 'a' and an integer for 'b'. Foo must return a
string. In the second function you have to cast the params and return value to fitthe correct type. Main benefit
is that the developer could easy see the correct type and use it in the correct way. IDE´s and at last the
compiler could find type errors. In worst case function 'foo_2' could still occur an type error during runtime. Go
allows type save casts but if it will cast in the wrong type an error occur.

Static typing helps developer to prevent errors. But if it helps to understand the code and supports readability
depend on the developer who uses it.

Lets take a look on Lua functions to see how it will look there:

    function foo (n)
        n = n or 1
        n + 1
        return n
    end

Without saying which concept is better, dynamic or static could you answer following questions?

- Which type has the parameter? | How should foo be called?
- Will you return something? And which type will it have?
- Must the parameter be set?

That's not really fair. There still exist documentation and the function parameter naming could show if its need and
which type is to use. But you don´t have compiler or IDE support for these kind of typing.

Should foo be called like foo("abc") it will occurs an invalid-type-exception during runtime and in worst case the
programme will break.

One of the benefits of dynamic typing is it is much easier to write you don´t care about expilict typing and variables
could reused for what the developer need not for what it is declared. Code could be much smaller and during develop
the developer know which types he uses or maybe he don´t care. Take a look at anonymous functions you call theme
in a explicit context were you know the types. So why should the types defined there is only one way to use and it´s
absolute clear?

== More Characteristics

=== Importing Modules

In Lua the creators say with a smily maybe the import is maybe to dynamic. The linking to the "math"-library is
never be checked. During execution it is there or the program throws an error.

    local m = require "math"
    print(m.sqrt(10))

Go has static linking. Special is that the whole Path the the imported Package/Library has to be written. If the
developer uses a state of the art IDE, that IDE handles imports for the Developer so he hasn´t to care.

    import "fmt"
    fmt.println("Hello World")

=== Pointers / References / Call By Value

*Lua* don´t offer Pointers (of course internal it uses references to memory) depending on the data-type there were
reference or values copied. Lua handles allocation and deallocation of strings and other objects.

Or more simple all types are passed by value, but function, table, userdata and thread are reference types. An
exception is String it is immutable and will handled as a reference to a new created string. So it has same behaves
like a value type, but with better performance. (i have no idea why better performance)

*Go* offer Pointer and all functionality which came with that opportunity.


= TBD - bin mir nicht sicher, ob ich generic for sowie interfaces & Objects reinnehmen soll. is evtl was für OO

=== generic for gehört zu interessanten functions constructen. dran denken pairs () liefert auch eine Funktion kein array is eine function
 for k, v in pairs(t) do
    print(k, v)
 end

 for <var-list> in <exp-list> do
      <body>
  end

https://www.lua.org/pil/7.1.html

=== Interfaces?? / Objects - TBD - bin mir nicht sicher, ob ich generic for sowie interfaces & Objects reinnehmen soll. is evtl was für OO

The table type implements associative arrays. An associative array is an array that can be indexed not only with numbers,
 but also with strings or any other value of the language, except nil. Moreover, tables have no fixed size; you can add
 as many elements as you want to a table dynamically. Tables are the main (in fact, the only) data structuring mechanism
  in Lua, and a powerful one. We use tables to represent ordinary arrays, symbol tables, sets, records, queues, and
  other data structures, in a simple, uniform, and efficient way. Lua uses tables to represent packages as well. When we
   write io.read, we mean "the read entry from the io package". For Lua, that means "index the table io using the string
    "read" as the key".

Tables in Lua are neither values nor variables; they are objects. If you are familiar with arrays in Java or Scheme,
then you have a fair idea of what we mean. However, if your idea of an array comes from C or Pascal, you have to open
your mind a bit. You may think of a table as a dynamically allocated object; your program only manipulates references
(or pointers) to them. There are no hidden copies or creation of new tables behind the scenes. Moreover, you do not have
 to declare a table in Lua; in fact, there is no way to declare one. You create tables by means of a constructor
  expression, which in its simplest form is written as {}:

first-class functions + tables ~ objects
syntactical sugar for methods - handles self

a:foo(x) => a.foo(a,x)

    function a:foo(x)
        ...
    end

=>

    a.foo = function(self,x)
        ...
    end

Lua doesn´t need Interfaces in the usual meaning. An interface says that an Object which includes an Interface has specific
functions, methods or properties. But in Lua there are no Objects like in Java. But OO Programming way is possible if
functions and tables are seen as an Object

*Go*

interfaces vai

    type x interface{
    }



== Functions

Now the basics are spoken. Take a deeper dive into functions of both languages.

=== Scope

*Lua* uses lexical scoping this means unlike global variables, local variables have their scope limited to the block
where they are declared. A block is the body of a control structure, the body of a function, or a chunk (the file or
string with the code where the variable is declared). That´s the same for functions, so we could create typical
closures like:

    function sequence ()
        local i = 0
        return function ()
            i ++
            return i
        end
    end

*Go* has nearly the same behaviour except global variables, Go doesn´t contain them. The scoping of go is called
lexical blocks which means the same as Lua´s lexical scope. The syntactic block is a sequence of statements enclosed
in braces that surrounds the body of a function or loop. There is a lexical scope for the entire source code, called
the universal scope; for each package, file, function, loop, switch, switch-case, select and of course for each lexical
scope. Imports are in the file level scope f.e. fmt. Closures in *Go* looks nearly the same as in Lua:

    func sequence() func() int  {
    	i := 0
    	return func() int {
    		i++
    		return i
    	}
    }

How there is to see both could handle closures and functions are first class values/citizens. Which means
you could treat functions as values. Functions could be function parameter, return values (higher-order functions)
or stored in variables.

=== Function Nesting

As expected both languages have function nesting like to see in *Lua*

    function foo(x)
        function p(y)
            print(y)
        end
        p(2*x)
    end

and *Go*

    func foo(x int) {
    	b := func(y int) {
    		fmt.Println(y)
    	}
    	b(2 * x)
     }

=== Anonymous Functions

Beside function nesting there are in both languages anonymous functions

    add = (function (x,y) return x+y end)   // Lua
    add := func(x int, y int) int {         // Go
    		return x + y
    	}


== More Functional Samples

=== Map/Reducer sample

The "canonical" example of a function that takes another function as a parameter is map. Unfortunately map does not
come with *Lua*, so we'll have to code it ourselves.

    function map(func, array)
        local new_array = {}
        for i,v in ipairs(array) do // ipairs returns simple said the key and value
            new_array[i] = func(v)
        end
        return new_array
    end

This is a simple map implementation that only works with one array. But it works well:

    return table.concat(map(double, {1,2,3}),",") // 2,4,6

Its very funny that *Go* same as Lua does not include a map function. So to compare code it ourselve.

    func Map(foo func(interface{}) interface{}, arr []interface{}) interface{} {
    	temp := new([]interface{})
    	for _, v := range arr {
    		*temp = append(*temp, foo(v))
    	}
    	return temp
    }

In the Go example there is to see that interface{} is very often used to use Map with every type. That looks very ugly
and does not support the developer how the function should used. To use it more explicit and with the common
"Object.Function()"-Notation for using functions on Objects Map could written for a type explicit.

    func (s *SomeType) Map(mapperFunction AnyInterface) SomeReturnValue {
    	for i, el := range s.data {
	    	s.data[i] = mapperFunction(el)
	    }
	return s
    }
    s := make(SomeType)
    s.Map(AnyFunction)

== Exception handling

*Lua* uses function nesting for its error handling. The _pcall_-Function (Protacted Call) tooks the functions which
should calls and could produce an error and calls them. _pcall_ returns two values a ok-Value should all be ok :)
and a second value with the error message. This is a very good example how function nesting and multi assignment work.

    local ok, err = pcall(function() <block/error> end)
    if not ok then
        print(err) // error handling
    end

Simple semantic you need only 2 functions - there you could see how functional programming is a major part of lua.

For *Go* its nearly the same. For functions which the developer it is usual to handle errors like http reject that
function has to return an error. There is no need of _pcall_ the called functions have to include there own error
statements like:

    ok, err := http.Get(url)
    if err != nil {
        fmt.println(err) // error handling
    }

this example shows a common case in which the program should not crash. we only need to handle the
error, maybe across calling the Get again or what ever.

The second handling strategy is for unexpected error the _panic_-Function which is reserved for states, behaviour of
the program. Like cleanup a Webserver or write into a logfile and stop the application more controled or maybe recover.
Panics could be thrown very easy.

	panic("42")

and similar simple cached

    func Parse(input string) (s *Syntax, err error){
        defer func() {                              // nearly same as finally
            if p:= recover(); p != nil {
                err = fmt.Errorf("internal error: %v", p)
            }
        }()
        // .. parser ..
    }

*Go* includes by design the _pcall_ from lua. But the _pcall_ has to be build into the functions as a expected behavior,
as an additional return value. This is a better approach and have better performance wrapping every unsafe function into
a _pcall_.
The Panic mechanism allows depending of the programmers intention to recover the Program. Do not forget sometimes
it is the right response to panic and maybe break the application.


== Routinen vs Coroutines or Async and Threading

*Lua* offers coroutine which are similar to a the well known thread (in the sense of multithreading): a line of execution,
with its own stack, its own local variables, and its own instruction pointer; but sharing global variables and
mostly anything else with other coroutines. The main difference between threads and coroutines is that, conceptually
(or literally, in a multiprocessor machine), a program with threads runs several threads concurrently. Coroutines, on
the other hand, are collaborative: A program with coroutines is, at any given time, running only one of its coroutines
and this running coroutine only suspends its execution when it explicitly requests to be suspended.

A coroutine has 3 states: suspended, running, dead. It could be stored in variables and coroutines has functionality
to get its state, close, yield and creating them.

    co = coroutine.create(function ()
           for i=1,10 do
             print("co", i)
             coroutine.yield()
           end
         end)

Now, when we resume this coroutine, it starts its execution and runs until the first yield:

    coroutine.resume(co)    // 1

If the status will be checked it return the suspended-state.

    print(coroutine.status(co))   --> suspended

This can be done till the for-loop is ending. Than the state of the coroutine will changed to dead. And it could not
longer be called without an exception.

For example downloading different files using http. It could be downloaded in sequence (tooks a long time)
or is there currently no data available the coroutines could yield and another coroutine could run and so own.

 function download (host, file)
      local c = assert(socket.connect(host, 80))// creates connection
      local count = 0                           // counts number of bytes read
      c:send("GET " .. file .. " HTTP/1.0\r\n\r\n")
      while true do
        local s, status = receive(c)
        count = count + string.len(s)
        if status == "closed" then break end
      end
      c:close()
      print(file, count)
    end

    function receive (connection)
      connection:timeout(0)                     // do not block
      local s, status = connection:receive(2^10)
      if status == "timeout" then
        coroutine.yield(connection)
      end
      return s, status
    end

The next function ensures that each download runs in an individual thread:

    threads = {}                                // list of all live threads
    function get (host, file)
      local co = coroutine.create(function ()   // create coroutine
        download(host, file)
      end)
      table.insert(threads, co)                 // insert into list
    end

Coroutines are a kind of collaborative multithreading. There a not constructed as real multithreading like go-routines.
While a coroutine is running, it cannot be stopped from the outside! However, with non-preemptive multithreading,
whenever any thread calls a blocking operation, the whole program blocks until the operation completes.

*Go* on follows totally other concepts of async and threading. Go supports multithreading in form of goRoutines which a
very leight and multiplext. This means a goroutine could be executied on several OS threads. This concept offers the
opportunity the use all cores of a machine. This goroutines in common use does not use blocking. It is possible be
unusual. Goroutines uses communication to pass data from one routine into another. This method are inspired by Hoare´s
CSP (1978) and Dijkstra´s guarded commands (1975). In these concepts there is no need to share memory or variables to
pass data between goroutines the communicate to handle that. For these go include so called channels in which could be
written or read. Depending on the use case with or without buffer. The default channel does not have a buffer size, so
if a goroutine whould write into a channel it wait till on the other side is a receiver of the massage. Similar to that
the receiver wait till someone write into the channel. With this simple rules routines could be synchronised.


    type Ball struct{ hits int }                    // Ball contains the number of hits.
    func main() {
        table := make(chan *Ball)
        go player("ping", table)
        go player("pong", table)
        table <- new(Ball)                          // game on; toss the ball
        time.Sleep(1 * time.Second)
        <-table                                     // game over; grab the ball
    }
    func player(name string, table chan *Ball) {
        for {
            ball := <-table
            ball.hits++
            fmt.Println(name, ball.hits)
            time.Sleep(100 * time.Millisecond)
            table <- ball
        }
    }

This example shows a lot. Start with definitions of unusual operators and reserved words:

-  _chan_ is the type of Channels
- _go_-command tells the machine that this should be startet asynchrounisly as a independent goroutine. (very easy
syntax)
-  _some_value_ means to write _some_value_ into the channel
-  a = \<- _some_channel_ tooks the value from a channel

Lets look deeper into the example above.

- In the first line a struct is created which contains the hits (boring)
- the main-function creats a table which is a channel of Ball-Pointer
- than two player-functions will lunched. Both get a name and took a channel of Ball-Pointer. And start in a infinite
loop: wait to read from table, hit the ball, write the hits to the console, wait and write to the table channel.
- now the game starts. The first message is written into the table channel (do not forget the two player-functions
are started and waiting for the first message to handle the ball)
- wait
- take a message from the channel (=> the two players both wait for a message at the table-channel but non will be there)
GAME OVER!

Important to understand is that a Goroutine is not a Thread. Its much more lighter and does not share variables or memory.
It passes data using channels. That needs new control structures like the _select_ which is nearly the same as usual
_switch_-statements only for sequential goroutine handling. And of course if it is needed go offers blocking:

    var someThing sync.Mutex
    func BlockingExample() {
        something.Lock()
        defer something.Unlock()
    ...
    }

= Closing words

It´s hard to compare *Lua* and *Go*. Because *Lua* is made as an embaddable light wight dynamic script language and
*Go* as cloud programming language which is optimized for challanges of this disciplin. It is light wight static fast to
compile multi threading concurrent language. But both languages are very interessting and both have interessting concepts.

== CHEAT Sheet

https://powerman.name/doc/asciidoc

== Talk about LUA Functions
https://www.youtube.com/watch?v=wdRGOE1N-FA
https://pragprog.com/magazines/2013-05/a-functional-introduction-to-lua
https://www.lua.org/pil/6.html

Quellen
https://www.lua.org
https://www.youtube.com/watch?v=wdRGOE1N-FA (Talk von LUA in Moskau by Roberto Ierusalimschy)
http://vschart.com/compare/lua/vs/go-language
Programming in Lua by Roberto Ierusalimschy, Lua.org, December 2003
The Go Programming Language Donovan, Kernighan
Lecture of Johannes Weigend at Technical University of Applied Sciences Rosenheim (There i stole a lot of the go part)
https://www.youtube.com/watch?v=f6kdp27TYZs&feature=youtu.be&t=1 (Rob Pike Google I/0 2012 - Go Concurrency Patterns)